library(Seurat)
library(data.table)
library(Matrix)

get_plot_data <- function(Seu_object, Markers_dt, name_stage){
  my_markers <- unlist(strsplit(Markers_dt$V2,split = ";"))

  plotting_data <- Seu_object@assays$RNA@data
  plotting_data <- plotting_data[(rownames(plotting_data) %in% my_markers),]
  absent_markers <- my_markers[!(my_markers %in% rownames(plotting_data))]
  #adding empty values for absent markers
  absent_matrix <- Matrix(ncol = ncol(plotting_data),
                          nrow = length(absent_markers), 
                          data = 0)
  colnames(absent_matrix) <- colnames(plotting_data)
  rownames(absent_matrix) <- absent_markers
  plotting_data <- rbind(plotting_data, absent_matrix)
  rm(absent_matrix, absent_markers)
  
  
  #Creating DT for renaming
  rename_dt <- data.table(transcripts = strsplit(Markers_dt$V2, ";"),
                          group_names = Markers_dt$V1)
  
  rename_dt$transcripts <- sapply(rename_dt$transcripts, unlist)
  
  
  #Grouping transcripts 
  rename_transcripts <- function(transcripts, group_name, mtx_in = plotting_data){
    ifelse(length(transcripts) == 1,
           mtx_data <- plotting_data[rownames(plotting_data) %in% transcripts, ],  
           mtx_data <- apply(plotting_data[rownames(plotting_data) %in% transcripts, ], 2, sum))
    
    new_mtx <- Matrix(nrow = 1,
                      ncol = ncol(plotting_data), 
                      data = mtx_data, sparse = T)
    rownames(new_mtx) <- group_name
    colnames(new_mtx) <- colnames(plotting_data)
    return(new_mtx)
  }
  
  plotting_data <- mapply(rename_transcripts, rename_dt$transcripts, rename_dt$group_names,
                          SIMPLIFY = T, USE.NAMES = F)
  
  plotting_data <- do.call(rbind, plotting_data)
  
  barcode <- colnames(plotting_data)
  transcripts <- rownames(plotting_data)
  plotting_data <- t(plotting_data)
  plotting_data <- as.data.table(plotting_data)
  names(plotting_data) <- transcripts
  plotting_data$barcode <- barcode
  rm(barcode, transcripts)
  plotting_data$cluster <- Seu_object$seurat_clusters
  plotting_data <- melt.data.table(plotting_data, id.vars= c("barcode", "cluster"),  variable.name = "transcript" , variable.factor = FALSE)
  plotting_data$stage <- name_stage
  
  plotting_data[, ncells := .N, by = cluster]
  
  #plotting_data[value > 0, n.exp := .N, by = .(transcript, cluster)]
  
  #exprerimental_version
  
  #plotting_data[, mean.exp := expm1(value), by = .(transcript, cluster)]
  
  #working_version
  plotting_data[value > 0, mean.exp := mean(value, na.rm=T), by = .(transcript, cluster)]
  
  PercentAbove <- function(x){
    return(length(x = x[x > 0]) / length(x = x))
  }
  
  #Working_version
  #plotting_data[, pct.exp := (n.exp/ncells)*100] 
  
  plotting_data[, pct.exp := PercentAbove(value)*100, by = .(transcript, cluster)]
  
  plotting_data <- plotting_data[,.(cluster, transcript, stage, mean.exp, pct.exp)]
  plotting_data[is.na(plotting_data)] <- 0
  plotting_data[, max.pct := max(pct.exp), by = .(transcript, cluster)]
  plotting_data[, max.exp := max(mean.exp), by = .(transcript, cluster)]
  # 
  plotting_data$mean.exp <- NULL
  plotting_data$pct.exp <- NULL
  # 
  #setnames(plotting_data, "max.exp", "mean.exp")
  setnames(plotting_data, c("max.pct", "max.exp"), c("pct.exp", "mean.exp"))
  plotting_data <- unique(plotting_data)
  return(plotting_data)
}

############################################################################################################
##Seurat build-in DotPlot function  

# function (object, assay = NULL, features, cols = c("lightgrey", "blue"),
#           col.min = -2.5, col.max = 2.5, dot.min = 0, dot.scale = 6, 
#           idents = NULL, group.by = NULL, split.by = NULL, cluster.idents = FALSE, 
#           scale = TRUE, scale.by = "radius", scale.min = NA, scale.max = NA) 
# {
#   #Setting the assay as default from Seurat object
#   assay <- assay %||% DefaultAssay(object = object)
#   DefaultAssay(object = object) <- assay
#   
#   #Setting the colour number from the palette  
#   split.colors <- !is.null(x = split.by) && !any(cols %in% 
#                                                    rownames(x = brewer.pal.info))
#   
#   #Choosing the option for the scale.func - IDK what is it
#   scale.func <- switch(EXPR = scale.by, size = scale_size, 
#                        radius = scale_radius, stop("'scale.by' must be either 'size' or 'radius'"))
#   feature.groups <- NULL
#   
#   #Feature groups(very huyevaia option)
#   
#   if (is.list(features) | any(!is.na(names(features)))) {
#     feature.groups <- unlist(x = sapply(X = 1:length(features), 
#                                         FUN = function(x) {
#                                           return(rep(x = names(x = features)[x], each = length(features[[x]])))
#                                         }))
#     if (any(is.na(x = feature.groups))) {
#       warning("Some feature groups are unnamed.", call. = FALSE, 
#               immediate. = TRUE)
#     }
#     features <- unlist(x = features)
#     names(x = feature.groups) <- features
#   }
#   cells <- unlist(x = CellsByIdentities(object = object, idents = idents))
#   data.features <- FetchData(object = object, vars = features, 
#                              cells = cells)
#   data.features$id <- if (is.null(x = group.by)) {
#     Idents(object = object)[cells, drop = TRUE]
#   }
#   else {
#     object[[group.by, drop = TRUE]][cells, drop = TRUE]
#   }
#   if (!is.factor(x = data.features$id)) {
#     data.features$id <- factor(x = data.features$id)
#   }
#   id.levels <- levels(x = data.features$id)
#   data.features$id <- as.vector(x = data.features$id)
#   if (!is.null(x = split.by)) {
#     splits <- object[[split.by, drop = TRUE]][cells, drop = TRUE]
#     if (split.colors) {
#       if (length(x = unique(x = splits)) > length(x = cols)) {
#         stop("Not enough colors for the number of groups")
#       }
#       cols <- cols[1:length(x = unique(x = splits))]
#       names(x = cols) <- unique(x = splits)
#     }
#     data.features$id <- paste(data.features$id, splits, sep = "_")
#     unique.splits <- unique(x = splits)
#     id.levels <- paste0(rep(x = id.levels, each = length(x = unique.splits)), 
#                         "_", rep(x = unique(x = splits), times = length(x = id.levels)))
#   }
#   data.plot <- lapply(X = unique(x = data.features$id), FUN = function(ident) {
#     data.use <- data.features[data.features$id == ident, 
#                               1:(ncol(x = data.features) - 1), drop = FALSE]
#     avg.exp <- apply(X = data.use, MARGIN = 2, FUN = function(x) {
#       return(mean(x = expm1(x = x)))
#     })
#     pct.exp <- apply(X = data.use, MARGIN = 2, FUN = PercentAbove, 
#                      threshold = 0)
#     return(list(avg.exp = avg.exp, pct.exp = pct.exp))
#   })
#   names(x = data.plot) <- unique(x = data.features$id)
#   if (cluster.idents) {
#     mat <- do.call(what = rbind, args = lapply(X = data.plot, 
#                                                FUN = unlist))
#     mat <- scale(x = mat)
#     id.levels <- id.levels[hclust(d = dist(x = mat))$order]
#   }
#   data.plot <- lapply(X = names(x = data.plot), FUN = function(x) {
#     data.use <- as.data.frame(x = data.plot[[x]])
#     data.use$features.plot <- rownames(x = data.use)
#     data.use$id <- x
#     return(data.use)
#   })
#   data.plot <- do.call(what = "rbind", args = data.plot)
#   if (!is.null(x = id.levels)) {
#     data.plot$id <- factor(x = data.plot$id, levels = id.levels)
#   }
#   if (length(x = levels(x = data.plot$id)) == 1) {
#     scale <- FALSE
#     warning("Only one identity present, the expression values will be not scaled", 
#             call. = FALSE, immediate. = TRUE)
#   }
#   avg.exp.scaled <- sapply(X = unique(x = data.plot$features.plot), 
#                            FUN = function(x) {
#                              data.use <- data.plot[data.plot$features.plot == 
#                                                      x, "avg.exp"]
#                              if (scale) {
#                                data.use <- scale(x = data.use)
#                                data.use <- MinMax(data = data.use, min = col.min, 
#                                                   max = col.max)
#                              }
#                              else {
#                                data.use <- log1p(x = data.use)
#                              }
#                              return(data.use)
#                            })
#   avg.exp.scaled <- as.vector(x = t(x = avg.exp.scaled))
#   if (split.colors) {
#     avg.exp.scaled <- as.numeric(x = cut(x = avg.exp.scaled, 
#                                          breaks = 20))
#   }
#   data.plot$avg.exp.scaled <- avg.exp.scaled
#   data.plot$features.plot <- factor(x = data.plot$features.plot, 
#                                     levels = features)
#   data.plot$pct.exp[data.plot$pct.exp < dot.min] <- NA
#   data.plot$pct.exp <- data.plot$pct.exp * 100
#   if (split.colors) {
#     splits.use <- vapply(X = as.character(x = data.plot$id), 
#                          FUN = gsub, FUN.VALUE = character(length = 1L),
#                          pattern = paste0("^((", paste(sort(x = levels(x = object), decreasing = TRUE), 
#                                                 collapse = "|"), ")_)"), replacement = "", 
#                          USE.NAMES = FALSE)
#     data.plot$colors <- mapply(FUN = function(color, value) {
#       return(colorRampPalette(colors = c("grey", color))(20)[value])
#     }, color = cols[splits.use], value = avg.exp.scaled)
#   }
#   color.by <- ifelse(test = split.colors, yes = "colors", no = "avg.exp.scaled")
#   if (!is.na(x = scale.min)) {
#     data.plot[data.plot$pct.exp < scale.min, "pct.exp"] <- scale.min
#   }
#   if (!is.na(x = scale.max)) {
#     data.plot[data.plot$pct.exp > scale.max, "pct.exp"] <- scale.max
#   }
#   if (!is.null(x = feature.groups)) {
#     data.plot$feature.groups <- factor(x = feature.groups[data.plot$features.plot], 
#                                        levels = unique(x = feature.groups))
#   }
#   plot <- ggplot(data = data.plot, mapping = aes_string(x = "features.plot", 
#                                                         y = "id")) + geom_point(mapping = aes_string(size = "pct.exp", 
#                                                                                                      color = color.by)) + scale.func(range = c(0, dot.scale), 
#                                                                                                                                      limits = c(scale.min, scale.max)) + theme(axis.title.x = element_blank(), 
#                                                                                                                                                                                axis.title.y = element_blank()) + guides(size = guide_legend(title = "Percent Expressed")) + 
#     labs(x = "Features", y = ifelse(test = is.null(x = split.by), 
#                                     yes = "Identity", no = "Split Identity")) + theme_cowplot()
#   if (!is.null(x = feature.groups)) {
#     plot <- plot + facet_grid(facets = ~feature.groups, scales = "free_x", 
#                               space = "free_x", switch = "y") + theme(panel.spacing = unit(x = 1, 
#                                                                                            units = "lines"), strip.background = element_blank())
#   }
#   if (split.colors) {
#     plot <- plot + scale_color_identity()
#   }
#   else if (length(x = cols) == 1) {
#     plot <- plot + scale_color_distiller(palette = cols)
#   }
#   else {
#     plot <- plot + scale_color_gradient(low = cols[1], high = cols[2])
#   }
#   if (!split.colors) {
#     plot <- plot + guides(color = guide_colorbar(title = "Average Expression"))
#   }
#   return(plot)
# }
# 
